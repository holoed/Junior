import Base (foldLeft, fmap)
import Externals (mkTuple2, fst, snd, empty, containsKey, findValue, error, singletonSet, union, emptySet, not, setContains)
import TypesExternals (mkTyCon, mkTyVar, mkTyLam, isTyVar, TyVar, TyLam, isInt, isFloat, isString, isChar)
import CodeGenerator (cataExp)

let bind = \m -> \f -> \r -> \s ->
 let p = ((m r) s) in
 let s2 = (fst p) in
 let x = (snd p) in
 ((f x) r) s2 in

let unit = \x -> \r -> \s -> mkTuple2 s x in

let ask = \r -> \s -> mkTuple2 s r in

let local = \f -> \m -> \r -> \s -> m (f r) s in

let put = \s2 -> \r -> \s -> mkTuple2 s2 () in

let get = \r -> \s -> mkTuple2 s s in

let runReaderState = \m -> \r -> \s -> (m r) s in

let freshName = bind get (\x ->
                bind (put (x + 1))(\i2 ->
                unit ("T" + x))) in

let prettyType = \t ->
  if (isTyCon t) then
    let p = extractTyCon t in
    (fst p) + " " + (foldLeft (\acc -> \x -> acc + (prettyType x)) "" (snd p))
  else if (isTyVar t) then
    extractTyVar t
  else if (isTyLam t) then
    let p = extractTyLam t in
    "(" + (prettyType (fst p)) + " -> " + (prettyType (snd p)) + ")"
  else error "This should not happen" in

let integerCon = mkTyCon "Int" empty in
let floatCon = mkTyCon "Float" empty in
let charCon = mkTyCon "Char" empty in
let stringCon = mkTyCon "String"  empty in

let literalToType = \lit ->
    if (isInt lit) then integerCon
    else if (isFloat lit) then floatCon
    else if (isChar lit) then charCon
    else if (isString lit) then stringCon
    else error "This should not happen" in

let lookup = \k -> \dict ->
    if (containsKey k dict) then
        (findValue k dict)
    else
        (mkTyVar k) in

let equalType = \t1 -> \t2 ->
  ((isTyVar t1) && (isTyVar t2)) && ((extractTyVar t1) == (extractTyVar t2)) in

let subs = \t -> \s ->
    if (isTyVar t) then
      let n = (extractTyVar t) in
      let t2 = (lookup n s) in
      if (equalType t t2) then t2
      else (subs t2 s)
    else if (isTyLam t) then
      let p = extractTyLam t in
      mkTyLam (subs (fst p) s) (subs (snd p) s)
    else if (isTyCon t) then
      let p = extractTyCon t in
      mkTyCon (fst p) (fmap (\x -> subs x s) (snd p))
    else (error "This should not happen") in

let getTVarsOfType = \t ->
  if (isTyVar t) then singletonSet (extractTyVar t)
  else if (isTyLam t) then
    let p = extractTyLam t in
    union (getTVarsOfType (fst p)) (getTVarsOfType (snd p))
  else if (isTyCon t) then
    let p = extractTyCon t in
    foldLeft (\acc -> \x -> union acc (getTVarsOfType x)) emptySet (snd p)
  else error "This should not happen" in

let fold2 = \f -> \acc -> \xs -> \ys ->
  if ((isEmpty xs) && (isEmpty ys)) then acc
  else fold2 f (f acc (head xs) (head ys)) (tail xs) (tail ys) in

let mgu = \a -> \b -> \s ->
  let p = mkTuple2 (subs a s) (subs b s) in
  if (((isTyVar (fst p)) && (isTyVar (snd p))) &&
      ((extractTyVar (fst p)) == (extractTyVar (snd p)))) then s
  else if ((isTyVar (fst p)) &&
           (not (setContains (extractTyVar (fst p)) (getTVarsOfType (snd p))))) then
              extend (extractTyVar (fst p)) b s
  else if (isTyVar (snd p)) then mgu b a s
  else if ((isTyLam (fst p)) && (isTyLam (snd p))) then
    let p1 = extractTyLam (fst p) in
    let p2 = extractTyLam (snd p) in
    mgu (fst p1) (fst p2) (mgu (snd p1) (snd p2) s)
  else if (((isTyCon (fst p)) && (isTyCon (snd p))) &&
           ((fst (extractTyCon (fst p))) == (fst (extractTyCon (snd p))))) then
           fold2 (\subst -> \t1 -> \t2 -> mgu t1 t2 subst) s args1 args2
  else error "This should not happen" in

let tp = \e ->
  cataExp e
    (\x -> unit mgu (literalToType v) bt s)
    (\s -> error "")
    (\s -> \e -> error "")
    (\e1 -> \e2 -> error "")
    (\s -> \e1 -> \e2 -> error "")
    (\p -> \e1 -> \e2 -> error "") in

()
